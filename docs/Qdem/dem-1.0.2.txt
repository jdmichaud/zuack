  The unofficial DEM format description
  Uwe Girlich, ggiirrlliicchh@@aaiixx552200..iinnffoorrmmaattiikk..uunnii--lleeiippzziigg..ddee
  v1.0.2, 7/30/96

  This document describes the DEM file format. This file format is the
  result of ``recording'' a game in Quake.  This documentation covers
  the versions 0.91 through 1.01.
  ______________________________________________________________________

  Table of Contents:

  1.      Introduction

  1.1.    Recording and Playback

  1.2.    Versions

  2.      Basics on the used client/server architecture

  3.      Some remarks on the used demo format

  3.1.    Advertising

  3.2.    Difference to DOOM

  3.3.    Opportunities of the DEM format

  3.4.    Problems of the DEM format

  4.      Some general remarks on the recording structure

  4.1.    Entity

  4.1.1.  Static Entity

  4.1.2.  Dynamic Entity

  4.1.3.  Temporary Entity

  4.2.    Life-cycles

  4.2.1.  Armor

  4.2.2.  (Multi) Player

  4.2.3.  Medikits, Chthon, etc.

  5.      File structure

  5.1.    Block of Messages

  5.2.    Message

  5.3.    Auxilliary routines

  6.      List of all message types

  6.1.    bad

  6.2.    nop

  6.3.    disconnect

  6.4.    updatestat

  6.5.    version

  6.6.    setview

  6.7.    sound

  6.8.    time

  6.9.    print

  6.10.   stufftext

  6.11.   setangle

  6.12.   serverinfo

  6.13.   lightstyle

  6.14.   updatename

  6.15.   updatefrags

  6.16.   clientdata

  6.17.   stopsound

  6.18.   updatecolors

  6.19.   particle

  6.20.   damage

  6.21.   spawnstatic

  6.22.   spawnbinary

  6.23.   spawnbaseline

  6.24.   temp_entity

  6.25.   setpause

  6.26.   signonum

  6.27.   centerprint

  6.28.   killedmoster

  6.29.   foundsecret

  6.30.   spawnstaticsound

  6.31.   intermission

  6.32.   finale

  6.33.   cdtrack

  6.34.   sellscreen

  6.35.   updateentity

  7.      Version History and Acknowledgements

  8.      About this document
  ______________________________________________________________________
  11..  IInnttrroodduuccttiioonn

  11..11..  RReeccoorrddiinngg aanndd PPllaayybbaacckk

  Recording a game in Quake is as easy as playing it: you need some
  console commands to do it well.

  To create a single player DEM file start the game as usual and use the
  console command rreeccoorrdd nnaammee lleevveell [[ccddttrraacckk]]. This starts lleevveell with
  the currently selected skill and writes a record in nnaammee..ddeemm.  The
  recording will be written during all the play and this record file may
  grow unpredictable. Please make sure that you have some MB free disk
  space.  To stop this recording use ssttoopp or even quit the whole game
  (qquuiitt). To play it back, use the commands ppllaayyddeemmoo nnaammee or ttiimmeeddeemmoo
  nnaammee.

  To create a multi player DEM file start a ``listen'' server (recording
  from a dedicated server doesn't work) and use again the rreeccoorrdd
  command. This starts the selected level and the player at the server
  is alone in this level. Now all the other clients can connect to the
  server as usual and play what they like (deathmatch or team). The
  recording lasts until the player at the listen server uses the
  ddiissccoonnnneecctt, ssttoopp or qquuiitt command. The recording is from the point of
  view of the player at the listen server (client 1). The playback works
  as in the single player case.

  11..22..  VVeerrssiioonnss

  The documentation covers the following versions of Quake:

                         MS-DOS Shareware    0.91
                         MS-DOS Shareware    0.92
                         MS-DOS Shareware    1.00
                         MS-DOS Shareware    1.01
                         LINUX               0.92

  I could not find any important structural differences between these 5
  versions.  I actually write and check my documentation with LINUX and
  verify from time to time the MS-DOS recordings.

  This documentation isn't complete yet. Much decoding work remains to
  do (when I find the registered version in the mail) but I think this
  version it will help a lot in the understanding of the DEM format.

  22..  BBaassiiccss oonn tthhee uusseedd cclliieenntt//sseerrvveerr aarrcchhiitteeccttuurree

  Unlike DOOM and similar games Quake uses a ``server'' process (or even
  computer) which ``does'' all the game play. The ``clients'' (at least
  one) send to the server all input events (keys, mouse etc.) and
  receive all necessary information to draw the current picture. This
  prevents Quake from inconsistencies and the network load increases
  linear with the clients and not quadratic.

  The communication between server and clients is an asynchronous one.
  If you don't press any key, your computer won't send any packets to
  the server. But you receive from time to time (the network is
  unpredictable) a packet to describe the state of your client. It is
  obvious, that these packets must contain some time stamp information,
  the positions of all monsters in sight and some player state
  information like the current weapon, ammo etc.
  And exactly this is the DEM file format: the recording of all packets
  from the server to that client, who recorded the game (the first
  client). I call these packets ``blocks of messages'' and the single
  information (time, position, ammo etc.) ``message''.

  Whether the (listen) server process itself or the client process does
  the actual recording (file write access) isn't known but it is
  irrelevant for the understanding of the recording process.

  33..  SSoommee rreemmaarrkkss oonn tthhee uusseedd ddeemmoo ffoorrmmaatt

  33..11..  AAddvveerrttiissiinngg

  As the clever reader may know I'm the author of LMPC, the LMP/DMO/DEM
  Control Center. I recently included a DEM format support in it. This
  means:

  +o  ``recompile'' an existing DEM file to a simple text file (is ready
     and working) and

  +o  ``compile'' such a (modified) text file back to a DEM file (I'm
     just understanding how fflleexx and bbiissoonn do work).

     With such a tool it is very easy to analyze a DEM file but you can
     change it as well and so create a DEM file of a Quake game you
     never played.

  33..22..  DDiiffffeerreennccee ttoo DDOOOOMM

  The recording of a DOOM game consists only of the player input. All
  the rest is random-number dependent but totally deterministic and will
  be recalculated during the playback.

  If you change a single action in a LMP file all the rest is garbage
  because all monsters now behave totally different and sooner or later
  (sooner) you run into a wall. This can't happen in a DEM file. The
  full movement (of all objects) is stored in it.

  This confronts us with new opportunities but also new problems.

  33..33..  OOppppoorrttuunniittiieess ooff tthhee DDEEMM ffoorrmmaatt

  With the cceenntteerrpprriinntt message it is possible to include some _s_u_b_-_t_i_t_l_e_s
  in a recording file to inform the watchers what will happen next.

  The player coordinates and the camera positions may be different. This
  makes it possible to simulate the DUKE NUKEM 3D feature of stationary
  cameras.  The client doesn't draw the entity with the ``viewpoint''.
  This is in general the player entity itself but this entity can be
  changed to anything else with the setview message.  Another problem is
  the entity selection of the server, which sends to the client only the
  entities in sight (of the client). Therefore it is impossible to
  enlarge the distance between the camera and the recording player too
  much. They both have to be on the same side of a wall.

  For people with too much spare-time Quake can replace a full 3D
  modelling system for cartoons or the like.

  The demo file can contain console commands, which the client runs
  during replay. With this feature it should be possible to write a
  screenshot after every time stamp in the demo file. This makes it very
  easy to create a MPEG movie out of a DEM file.
  33..44..  PPrroobblleemmss ooff tthhee DDEEMM ffoorrmmaatt

  It is trivial to remove the ``godmode ON'' and other cheat messages
  from a recording. All the action doesn't change at all. These messages
  are only text print commands and the client behaviour doesn't depend
  on them.

  Fortunately I found a redundancy in the DEM format, which allows to
  detect a ``godmode'' cheater: Every damage message contains the health
  and armor decrease value. The next status line description (it
  contains the health and armor values to be displayed) can so be
  checked.

  44..  SSoommee ggeenneerraall rreemmaarrkkss oonn tthhee rreeccoorrddiinngg ssttrruuccttuurree

  44..11..  EEnnttiittyy

  An entity is an object. This may be the whole level (described by a
  BSP file), the player (described by a MDL file), an explosion
  (described by a SPR file) or the like.

  There are different kinds of entities.

  44..11..11..  SSttaattiicc EEnnttiittyy

  A static entity doesn't interact with the rest of the game. These are
  flames (pprrooggss//ffllaammee..mmddll) and the like. It will be created by the
  spawnstatic message.  It will never be necessary to reference such an
  entity. They don't get an entity number. The maximum number of static
  entities is 127.

  44..11..22..  DDyynnaammiicc EEnnttiittyy

  A dynamic entity is anything which changes its behaviour or its
  appearance.  These are ammunition boxes, spinning armors, player
  models and the like.  A dynamic entity will be created by the
  spawnbaseline message. The maximum number of dynamic entities is 449.

  44..11..33..  TTeemmppoorraarryy EEnnttiittyy

  A temporary entity will be created by the temp_entity message.  A
  temporary entity is a (as the name indicates) short time entity.

  Quake uses these entities for hits on the wall (point-like entities)
  or for the Thunderbolt flash (line-like entities).

  For more information on temporary entities look in section
  ``temp_entity''.

  44..22..  LLiiffee--ccyycclleess

  The Quake objects pass different life phases. The following
  information is not DEM specific but it may be of general interest to
  understand the co-operation of all the messages.

  44..22..11..  AArrmmoorr

  +o  To enable the client to display an armor the serverinfo message
     asks for the ``progs/armor.mdl'' model file and the
     ``items/armor1.wav'' sound file.

  +o  The armor starts its life with a spawnbaseline message during the
     initialize phase. The armor is now a dynamic entity and spins
     around.

  +o  The corresponding updateentity message appears only, if the camera
     is near enough to see the armor.

  +o  The player gets it in the play. This results in the sound message
     ``items/armor1.wav'' and a print message ``you got armor'' and the
     stufftext message ``bf\n'' to make a short flash.

  +o  The updateentity message for the armor doesn't appear ever again:
     the player got it.

  +o  From this moment the corresponding bit in the iitteemmss variable in the
     clientdata message will be 1 and the aarrmmoorrvvaalluuee variable get its
     maximum (100/150/200).  From the iitteemmss bit follows the color of the
     picture to be drawn in the lower left corner of the status line.

  +o  Now the player may be hit by a grenade. The total damage value
     (damage=take+save) will be split in take (hheeaalltthh--==ttaakkee) and save
     (aarrmmoorrvvaalluuee--==ssaavvee).  The save amount depends on the armor type
     (none/green/yellow/red): ssaavvee==00..00//00..33//00..66//00..88**ddaammaaggee.  The damage
     message in the DEM file tells the reduction of the current armor.
     With the old clientdata value and the reduction it is easy to
     recompute the new clientdata aarrmmoorr value.  Any difference betrayes
     the cheat code player.

  +o  After some severe hits the aarrmmoorrvvaalluuee variable is 0 and the iitteemmss
     bit falls back to 0 as well. There is no armor anymore.

  44..22..22..  ((MMuullttii)) PPllaayyeerr

  The following describes the deathmatch DEM messages of the two players
  Alice and Bob. Alice records the game from her --lliisstteenn 33 server.

  +o  The serverinfo message contains the ``maxclients 3'' command to
     show how many clients are (at most) in this recording.

  +o  During the 1st initialization phase there are 3 spawnbaseline
     messages to create the player models. In the 2nd initialization
     phase player 0 gets its name (Alice), color and frag count (0) .
     The other 2 players get an empty name string. In the 3rd phase
     Alice gets again her name and color.  All these phases are
     controlled by signonnum messages.

  +o  The game starts. Alice (entity 1) is alone in the game and looks
     around.

  +o  Bob connects to Alice's server and it appears entity 2 (Bob's
     player model) a transport end temporary entity and a print message
     (``Bob entered the game'') to inform everyone. Then the player 1
     (Bob) gets his updatename and updatecolors message.

  +o  Alice doesn't hesitate and runs for him and shoots him with the
     Shotgun.  During every shot the clientdata message reduces the ammo
     count, the angles[0] command shows the wobble of Alice's screen and
     the weaponframe command selects the corresponding weapon frames.
     There is a sound message to start the wweeaappoonnss//gguunnccoocckk..wwaavv file.
     Entity 1 gets its attack_state command. Alice hits Bob and so
     appear many particle messages (blood).  Every Shotgun shot contains
     6 parts. This means the shot can create 6 particles (full hit) and
     0 temporary entities (type 2: wall hits) or 0 particles and 6
     temporary entities or anything in between. If there was at least
     one particle Bob creates a sound message to start ppllaayyeerr//ppaaiinn??..wwaavv.

  +o  Alice kills Bob. This creates the sound message to start
     ppllaayyeerr//ddeeaatthh11..wwaavv. Then comes the updatefrags message to give Alice
     1 frag and a print message to inform everyone ``Bob chewed on
     Alice's boomstick''. A new entity will be created on the fly with
     an updateentity message to display Bob's backpack.

  +o  Bob is dead, his entity 2 model remains in the death frame.

  +o  After some seconds he starts again by pressing SSPPAACCEE. He reappears
     in a totally different part of the level. The dead body transforms
     from entity 2 to entity 4 (maxclients+1) and a temporary entity
     (transport end) informs about his return. He is out of sight from
     the point of Alice's view. This means there is no entity 2
     updateentity message.

  +o  Bob runs to Alice's room. He goes through a slipgate and appears
     with 4 temporary entities (type 11: transport end) and the entity 2
     in her room.

  +o  Bob shoots and kills Alice. The scenario is the same as above. Only
     the damage messages appear now too, because Alice was hit.

  +o  Bob uses the say console command (ssaayy tthhiiss ssuucckkss) and in the DEM
     file appears a print message ``Bob: this sucks''.

  +o  Bob disconnects from Alice's server. This results in a print
     message ``Bob left the game with 1 frags'' and updatename and
     updatecolor messages to remove client 2 (or player 1). It is a bit
     strange but there are 2 updatefrags messages: player 1 gets first 0
     frags (this I understand) and then again 1 frag (this I don't
     understand at all).

  +o  Entity 2 represents now the dead player 1.

  +o  Alice spins around (it is possible even if you are dead) and the
     two dead bodies from Bob are totally white because they represent
     player 1 and he got (as he left) the updatecolor message with the
     standard colors 0 and 0. She is alone, restarts again her play,
     goes to the level end slipgate and get the ranking screen
     (intermission message) with only one player (Alice). Then she stops
     the recording. The DEM file ends with a disconnect message.

  44..22..33..  MMeeddiikkiittss,, CChhtthhoonn,, eettcc..

  will be included later (anyone volunteer?)

  55..  FFiillee ssttrruuccttuurree

  To describe the file structure, which is very complicated, I use C
  like program fragments and ssttrruucctt definitions. This simplifies my task
  a lot.

  I invented all used names (messages, variables etc.) for myself, took
  them from the Quake binary, QuakeEd or from the QuakeC examples.

  All DEM files start with an ASCII string of the cd track which was
  given to the rreeccoorrdd command. The string is terminated by a new line
  character (00xx00AA). If you didn't give a cd track number the string is
  ``-1''. This means almost all DEM files start with ``-1\n''.  It seems
  that this header was included at the very end of the developement.  It
  doesn't fit to the rest at all.

  All the rest of the DEM file consists of ``blocks'' of ``messages''.

  55..11..  BBlloocckk ooff MMeessssaaggeess

  At first some coordinate ttyyppeeddeeff's:

       typedef float vec_t;

       typedef vec_t[3] vec3_t;

  This is the block structure:

       typedef struct {
                        long            blocksize;
                        vec3_t          angles;
                        char[blocksize] messages;
                      } block_t;

  A block of messages starts with a size. Then follow 3 angles which
  describe the camera viewing direction. All the rest of a block are
  bytes which form one or more messages.

  I believe that one block is one network packet from the server to the
  client.

  55..22..  MMeessssaaggee

  This is the message structure:

       typedef struct {
                        unsigned char ID;
                        char[???]     messagecontent;
                      } message_t;

  The length of a message depends on its type (or IIDD).

  55..33..  AAuuxxiilllliiaarryy rroouuttiinneess

  Here comes the definition of some small auxilliary routines to
  simplify the main message description. ggeett__nneexxtt__uunnssiiggnneedd__cchhaarr,
  ggeett__nneexxtt__ssiiggnneedd__cchhaarr, ggeett__nneexxtt__sshhoorrtt and ggeett__nneexxtt__lloonngg are basic
  functions and they do exactly what they are called. Please note: bbyyttee,
  cchhaarr or sshhoorrtt will be converted to lloonngg.  Second note: all multi-byte
  structures in the DEM file are Intel ordered.

  In the following I often use a count variable

  int i;

  without declaration. I hope this does not confuse you.

       long ReadByte
       {
         return (long) get_next_unsigned_char;
       }

       long ReadChar
       {
         return (long) get_next_signed_char;
       }

       long ReadShort
       {
         return (long) get_next_short;
       }

       long ReadLong
       {
         return get_next_long;
       }

  Note: A signed angle in a single byte. There are only 256 possible
  direction to look into.

       vec_t ReadAngle
       {
         return (vec_t) ReadChar / 256.0 * 360.0;
       }

  vec_t ReadCoord
  {
    return (vec_t) ReadShort * 0.125;
  }

  The string reading stops at '\0' or after 0x7FF bytes. The internal
  buffer has only 0x800 bytes available.

       char* ReadString
       {
         char* string_pointer;
         char string_buffer[0x800];

         string_pointer=string_buffer;
         for (i=0 ; i<0x7FF ; i++, string_pointer++) {
           if (! (*string_pointer = ReadChar) ) break;
         }
         *string_pointer = '\0';
         return strdup(string_buffer);
       }

       long ReadEntity
       {
         return ReadShort;
       }

  66..  LLiisstt ooff aallll mmeessssaaggee ttyyppeess

  The easiest way to explain a message is to give a short C like program
  fragment to parse such a message. Each message can be described by its
  IIDD or its name.

  66..11..  bbaadd

     IIDD 00xx0000

     ppuurrppoossee
        Something is bad. This message should never appear.

     ppaarrssee rroouuttiinnee
        none

  66..22..  nnoopp

     IIDD 00xx0011

     ppuurrppoossee
        No operation.

     ppaarrssee rroouuttiinnee
        none

  66..33..  ddiissccoonnnneecctt

     IIDD 00xx0022

     ppuurrppoossee
        Disconnect from the server. Stops the game.

     ppaarrssee rroouuttiinnee
        none

  66..44..  uuppddaatteessttaatt

     IIDD 00xx0033

     ppuurrppoossee
        Updates directly any values in the player state.

     vvaarriiaabblleess

        lloonngg iinnddeexx;;
           is the index in the ppllaayyeerrssttaattee array.  Possible indices are:

                            index    variable
                                0    hheeaalltthh
                                1    ??? (not used)
                                2    wweeaappoonnmmooddeell
                                3    ccuurrrreennttaammmmoo
                                4    aarrmmoorrvvaalluuee
                                5    wweeaappoonnffrraammee
                                6    aammmmoo__sshheellllss
                                7    aammmmoo__nnaaiillss
                                8    aammmmoo__rroocckkeettss
                                9    aammmmoo__cceellllss
                               10    wweeaappoonn
                               11    ttoottaall__sseeccrreettss
                               12    ttoottaall__mmoonnsstteerrss
                               13    ffoouunndd__sseeccrreettss
                               14    ffoouunndd__mmoonnsstteerrss
                               15    ???
                                .

                           .
                           .
                          31    ???

        Normal DEM files use index 11 to 14 only.

        lloonngg vvaalluuee;;
           is the new value.

        lloonngg ppllaayyeerrssttaattee[[3322]];;
           is the array to describe the player state. Many other
           messages change (indirectly) some values in it.

     ppaarrssee rroouuttiinnee

          index = ReadByte;
          if (index > 0x1F) {
            error("svc_updatestat: %i is invalid", index);
          }
          value = ReadLong;
          playerstate[index] = value;

  66..55..  vveerrssiioonn

     IIDD 00xx0044

     ppuurrppoossee
        This message defines the version of the server. I never found
        such a message in a DEM file. It may be absorbed by the
        sseerrvveerriinnffoo message.

     vvaarriiaabblleess

        lloonngg sseerrvveerrpprroottooccooll;;
           is the version number of the server. It should be 00xx00FF.

     ppaarrssee rroouuttiinnee

          serverprotocol = ReadLong;
          if (serverprotocol != 0x0F) {
            error("CL_ParseServerMessage: Server is protocol %i instead of %i\n",
                                                           serverprotocol, 0x0F);
          }

  66..66..  sseettvviieeww

     IIDD 00xx0055

     ppuurrppoossee
        Sets the camera position to the origin of this entity.

     vvaarriiaabblleess

        lloonngg eennttiittyy;;
           is the entity with the camera.

     ppaarrssee rroouuttiinnee

          entity = ReadShort;

  66..77..  ssoouunndd

     IIDD 00xx0066

     ppuurrppoossee
        This message starts the play of a sound at a specific point.

     vvaarriiaabblleess

        lloonngg mmaasskk;;
           is a bitmask to reduce the amount of data.

        ffllooaatt vvooll;;
           is the volume of the sound (0.0 off, 1.0 max)

        ffllooaatt aatttteennuuaattiioonn;;
           is the attenuation of the sound.  Possible values (for all
           kind of sounds) are:

       value    QuakeC         purpose
       0        ATTN_NONE      i. e. player's death sound doesn't get an attenuation
       1        ATTN_NORM      the normal attenuation
       2        ATTN_IDLE      idle monsters get this attenuation
       3        ATTN_STATIC    spawnstaticsound messages get this attenuation

        lloonngg cchhaannnneell;;
           is the sound channel. There are 8 possible sound channels in
           Quake but the game uses 5 only.  Possible values are:

             value    QuakeC         purpose
             0        CHAN_AUTO      big powerups
             1        CHAN_WEAPON    weapon use sounds
             2        CHAN_VOICE     pain calls
             3        CHAN_ITEM      item get sounds
             4        CHAN_BODY      jump and fall sounds

        lloonngg eennttiittyy;;
           is the entity which caused the sound.

        lloonngg ssoouunnddnnuumm;;
           is the sound number in the sound-table.

        vvee33__tt oorriiggiinn;;
           is the origin of the sound.

     ppaarrssee rroouuttiinnee

          long entity_channel; // combined variable

          mask = ReadByte;
          vol = mask & 0x01 ? (float) ReadByte / 255.0 : 1.0;
          attenuation = mask & 0x02 ? (float) ReadByte / 64.0 : 1.0;
          entity_channel = ReadShort;
          channel = entity_channel & 0x07;
          entity = (entity_channel >> 3) & 0x1FFF;
          soundnum = ReadByte;
          for (i=0 ; i<3 ; i++) origin[i] = ReadCoord;

  66..88..  ttiimmee

     IIDD 00xx0077

     ppuurrppoossee
        This is the time stamp of a block of messages. A time message
        should appear in every block.

     vvaarriiaabblleess

        ffllooaatt ttiimmee;;
           is the time in seconds from the beginning of the current
           level (not of the recording).

     ppaarrssee rroouuttiinnee

          time = ReadFloat;

  66..99..  pprriinntt

     IIDD 00xx0088

     ppuurrppoossee
        The client prints the text in the top left corner of the screen.
        The text appears on the console as well.

     vvaarriiaabblleess

        cchhaarr** tteexxtt;;
           is the text to be displayed.  The text contains something
           like ``You get 5 shells''.  There are special non-printable
           characters in the text: ``\n'' means new line and ``\002''
           changes the color of the following text.  The value 2 may be
           a color number but I'm not sure about this.

     ppaarrssee rroouuttiinnee

          text = ReadString;

  66..1100..  ssttuufffftteexxtt

     IIDD 00xx0099

     ppuurrppoossee
        The client transfers the text to the console and runs it.

     vvaarriiaabblleess

        cchhaarr** tteexxtt;;
           is the command, which the client has to execute. These are
           commands like ``bf\n'' to make a flash after you take
           something.

     ppaarrssee rroouuttiinnee

          text = ReadString;

  66..1111..  sseettaannggllee

     IIDD 00xx00AA

     ppuurrppoossee
        This message set the camera orientation.

     vvaarriiaabblleess

        vveecc33__tt aanngglleess;;
           is the new camera orientation.

     ppaarrssee rroouuttiinnee

          for (i=0 ; i<3 ; i++) angles[i] = ReadAngle;

  66..1122..  sseerrvveerriinnffoo

     IIDD 00xx00BB

     ppuurrppoossee
        This message is usually one of the first messages after a level
        start.  It loads model and sound files.

     vvaarriiaabblleess

        lloonngg sseerrvveerrvveerrssiioonn;;
           is the version of the server.  It should be the same as the
           version of the client. Up to now this version was always
           00xx00FF.

        lloonngg mmaaxxcclliieennttss;;
           is the maximum number of clients in this recording. It is 1
           in single player recordings or the number after the --lliisstteenn
           command line parameter.

        lloonngg mmuullttii;;
           is 0 in single player recordings and 1 in multi player
           recordings. It actually toggles the ranking screen at the end
           of a level.

        cchhaarr** mmaappnnaammee;;
           is the name of the level.

        cchhaarr** pprreeccaacchhee__mmooddeellss[[225566]];;
           is the model-table. It will be filled up with model names.
           Many other messages contain an index in this array.  The
           first used index is 1.

        lloonngg nnuummmmooddeellss;;
           is the number of models in the model-table.

        cchhaarr** pprreeccaacchhee__ssoouunnddss[[225566]];;
           is the sound-table. It will be filled up with sound names.
           Many other messages contain an index in this array.  The
           first used index is 1.

        lloonngg nnuummssoouunnddss;;
           is the number of sounds in the sound-table.

     ppaarrssee rroouuttiinnee

          serverversion = ReadLong;
          if (serverversion != 0x0F) {
            error("Server returned version %i, not %i", serverversion, 0x0F);
          }
          maxclients = ReadByte;
          multi = ReadByte;
          mapname = ReadString;
          nummodels = 0;
          do {
            if (++nummodels > 255) error("Server sent too many model_precache");
            precache_models[nummodels] = ReadString;
          } while (*precache_models[nummodels]);
          numsounds = 0;
          do {
            if (++numsounds > 255) error("Server sent too many sound_precache");
            precache_sounds[numsounds] = ReadString;
          } while (*precache_sounds[numsounds]);

  66..1133..  lliigghhttssttyyllee

     IIDD 00xx00CC

     ppuurrppoossee
        This message defines a light style.

     vvaarriiaabblleess

        lloonngg ssttyyllee;;
           is the light style number.

        cchhaarr** ssttrriinngg;;
           is a string of letters ``a'' .. ``z'', where ``a'' means
           black and ``z'' white.  All known effects from nervous
           flashing: ``az'' to slow dimming: ``zyxwvu ... edcba'' can so
           be described.

     ppaarrssee rroouuttiinnee

          style = ReadByte;
          string = ReadString;

  66..1144..  uuppddaatteennaammee

     IIDD 00xx00DD

     ppuurrppoossee
        This message sets the player name.

     vvaarriiaabblleess

        lloonngg ppllaayyeerr;;
           is the internal player number (client 1 is player number 0).

        cchhaarr** nneettnnaammee;;
           is the new player name.

     ppaarrssee rroouuttiinnee

          player = ReadByte;
          netname = ReadString;

  66..1155..  uuppddaatteeffrraaggss

     IIDD 00xx00EE

     ppuurrppoossee
        This message updates the frag count of a specific player.

     vvaarriiaabblleess

        lloonngg ppllaayyeerr;;
           is the internal player number (client 1 is player number 0).

        lloonngg ffrraaggss;;
           is the new frag count for this player.

     ppaarrssee rroouuttiinnee

          player = ReadByte;
          frags = ReadShort;

  66..1166..  cclliieennttddaattaa

     IIDD 00xx00FF

     ppuurrppoossee
        This message updates the status line and the camera coordinates.

     vvaarriiaabblleess

        lloonngg mmaasskk;;
           is a bitmask to show which values are coming.

        ffllooaatt vviieeww__ooffss__zz;;
           is an additional view offset because the camera is at the
           origin of the entitiy and not at the eyes (is -8 if the
           player is death).

        ffllooaatt aanngg__ooffss__11;;
           is an additional offset of the first angle.

        vveecc33__tt aanngglleess;;
           indicates the camera direction change.

        vveecc33__tt vveell;;
           indicates the camera velocity.

        lloonngg iitteemmss;;
           contains a bit mask for the inventory:

  bit    value         QuakeC                 purpose
    0    00xx0000000000000011    IT_SHOTGUN             Shotgun (should be always 1)
    1    00xx0000000000000022    IT_SUPER_SHOTGUN       Double-barrelled Shotgun
    2    00xx0000000000000044    IT_NAILGUN             Nailgun
    3    00xx0000000000000088    IT_SUPER_NAILGUN       Supernailgun
    4    00xx0000000000001100    IT_GRENADE_LAUNCHER    Grenade Launcher
    5    00xx0000000000002200    IT_ROCKET_LAUNCHER     Rocket Launcher
    6    00xx0000000000004400    IT_LIGHTNING           Thunderbolt
    7    00xx0000000000008800    IT_EXTRA_WEAPON        extra weapon (there is no extra weapon)
    8    00xx0000000000110000    IT_SHELLS              Shells are active
    9    00xx0000000000220000    IT_NAILS               Flechettes are active
   10    00xx0000000000440000    IT_ROCKETS             Grenades are active
   11    00xx0000000000880000    IT_CELLS               Cells are active
   12    00xx0000000011000000    IT_AXE                 Axe (should be always 1)
   13    00xx0000000022000000    IT_ARMOR1              green Armor
   14    00xx0000000044000000    IT_ARMOR2              yellow Armor
   15    00xx0000000088000000    IT_ARMOR3              red Armor
   16    00xx0000001100000000    IT_SUPERHEALTH         Megahealth
   17    00xx0000002200000000    IT_KEY1                silver (keycard or runekey or key)
   18    00xx0000004400000000    IT_KEY2                gold (keycard or runekey or key)
   19    00xx0000008800000000    IT_INVISIBILITY        Ring of Shadows
   20    00xx0000110000000000    IT_INVULNERABILITY     Pentagram of Protection
   21    00xx0000220000000000    IT_SUIT                Biosuit
   22    00xx0000440000000000    IT_QUAD                Quad Damage
   23    00xx0000880000000000    unknown                unknown (is 0)
   24    00xx0011000000000000    unknown                unknown (is 0)
   25    00xx0022000000000000    unknown                unknown (is 0)
   26    00xx0044000000000000    unknown                unknown (is 0)
   27    00xx0088000000000000    unknown                unknown (is 0)
   28    00xx1100000000000000    unknown                Rune 1
   29    00xx2200000000000000    unknown                Rune 2
   30    00xx4400000000000000    unknwon                Rune 3
   31    00xx8800000000000000    unknown                Rune 4

           You can find the default value for iitteemmss in the parse
           routine: 00xx44000011. It looks like a programmer's mistake because
           this means Shotgun any yellow Armor. It should be 00xx11000011:
           Shotgun and Axe.

        lloonngg wweeaappoonnffrraammee;;
           is the frame of the weapon model.

        lloonngg aarrmmoorrvvaalluuee;;
           is the current armor.

        lloonngg wweeaappoonnmmooddeell;;
           is the model number of the weapon in the model-table.

        lloonngg hheeaalltthh;;
           is the current health.

        lloonngg ccuurrrreennttaammmmoo;;
           is the current number of the current ammunition.

        lloonngg aammmmoo__sshheellllss;;
           is the current number of shells.

        lloonngg aammmmoo__nnaaiillss;;
           is the current number of nails.

        lloonngg aammmmoo__rroocckkeettss;;
           is the current number of rockets.

        lloonngg aammmmoo__cceellllss;;
           is the current number of cells.

        lloonngg wweeaappoonn;;
           contains a bit mask for the current weapon:

       bit    value    QuakeC                weapon
       ?      00xx0000     not available         Axe
       0      00xx0011     IT_SHOTGUN            Shotgun
       1      00xx0022     IT_SUPER_SHOTGUN      Double-barrelled Shotgun
       2      00xx0044     IT_NAILGUN            Nailgun
       3      00xx0088     IT_SUPER_NAILGUN      Supernailgun
       4      00xx1100     IT_GRENADE_LAUNCHER   Grenade Launcher
       5      00xx2200     IT_ROCKET_LAUNCHER    Rocket Launcher
       6      00xx4400     IT_LIGHTNING          Thunderbolt
       7      00xx8800     IT_EXTRA_WEAPON       extra weapon (there is no extra weapon)

     ppaarrssee rroouuttiinnee

     long uk_bit_b10, uk_bit_b11; // unknown (unused ??)

     mask = ReadShort;
     view_ofs_z = mask & 0x0001 ? (float) ReadChar : 22.0;
     ang_ofs_1 = mask & 0x0002 ? (float) ReadChar : 0.0;
     angles[0] = mask & 0x0004 ? (vec_t) ReadChar : 0.0;
     vel[0] = mask & 0x0020 ? (vec_t) ReadChar : 0.0;
     angles[1] = mask & 0x0008 ? (vec_t) ReadChar : 0.0;
     vel[1] = mask & 0x0040 ? (vec_t) ReadChar : 0.0;
     angles[2] = mask & 0x0010 ? (vec_t) ReadChar : 0.0;
     vel[2] = mask & 0x0080 ? (vec_t) ReadChar : 0.0;
     items = mask & 0x0200 ? ReadLong : 0x4001;
     uk_bit_b10 = mask & 0x0400 ? 1 : 0; // bit 10
     uk_bit_b11 = mask & 0x0800 ? 1 : 0; // bit 11
     weaponframe = mask & 0x1000 ? ReadByte : 0;
     armorvalue = mask & 0x2000 ? ReadByte : 0;
     weaponmodel = mask & 0x4000 ? ReadByte : 0;
     health = ReadShort;
     currentammo = ReadByte;
     ammo_shells = ReadByte;
     ammo_nails = ReadByte;
     ammo_rockets = ReadByte;
     ammo_cells = ReadByte;
     weapon = ReadByte;

  66..1177..  ssttooppssoouunndd

     IIDD 00xx1100

     ppuurrppoossee
        Stops a sound. I never found such a message in a DEM file.

     ppaarrssee rroouuttiinnee

          long uk_short;  // unknown (an index??)

          uk_short = ReadShort;

  66..1188..  uuppddaatteeccoolloorrss

     IIDD 00xx1111

     ppuurrppoossee
        Updates the colors of the specified player.

     vvaarriiaabblleess

        lloonngg ppllaayyeerr;;
           is the internal player number (client 1 is player 0).
        lloonngg ccoolloorrss;;
           is the combined color of this player.

        lloonngg sshhiirrttccoolloorr;;
           is the color of the shirt (0 <= sshhiirrttccoolloorr <= 3).

        lloonngg ppaannttssccoolloorr;;
           is the color of the pants (0 <= ppaannttssccoolloorr <= 3).

     ppaarrssee rroouuttiinnee

          player = ReadByte;
          colors = ReadByte;
          shirtcolor = (colors>>4) & 0x0F;
          pantscolor = colors & 0x0F;

  66..1199..  ppaarrttiiccllee

     IIDD 00xx1122

     ppuurrppoossee
        This starts particles flying around. This happens, if a barrel
        explodes or blood particles fly after being hit by an axe,
        shells or nails.

     vvaarriiaabblleess

        vveecc33__tt oorriiggiinn;;
           is the origin of the particles.

        vveecc33__tt vveell;;
           is the velocity of the particles.

        lloonngg ccoolloorr;;
           is the color of the particles (blood is 73).

        lloonngg ccoouunntt;;
           is the number of the particles

     ppaarrssee rroouuttiinnee

          for (i=0 ; i<3 ; i++) origin[i] = ReadCoord;
          for (i=0 ; i<3 ; i++) vel[i] = (vec_t) ReadChar * 0.0625;
          color = ReadByte;
          count = ReadByte;

  66..2200..  ddaammaaggee

     IIDD 00xx1133

     ppuurrppoossee
        Tells how severe was a hit and from which points it came.

     vvaarriiaabblleess

        lloonngg ssaavvee;;
           will be subtracted from the current armor.

        lloonngg ttaakkee;;
           will be subtracted from the current health.

        vveecc33__tt oorriiggiinn;;
           is the origin of the hit. It points to the weapon of a
           monster or player (not the origin of the monster entity) or
           it is (0,0,0) if the damage was caused by drowning or
           burning.

     ppaarrssee rroouuttiinnee

          save = ReadByte;
          take = ReadByte;
          for (i=0 ; i<3 ; i++) origin[i] = ReadCoord;

  66..2211..  ssppaawwnnssttaattiicc

     IIDD 00xx1144

     ppuurrppoossee
        This message creates a static entity and sets the internal
        default values.

     vvaarriiaabblleess

        lloonngg SSttaattiiccEEnnttiittyyCCoouunntt;;
           is the number of already started static entities. The maximum
           number is 127.

        lloonngg ddeeffaauulltt__mmooddeelliinnddeexx;;
           is the model number in the model-table.

        lloonngg ddeeffaauulltt__ffrraammee;;
           is the frame number of the model.

        lloonngg ddeeffaauulltt__ccoolloorrmmaapp;;
           is the colormap number to display the model.
        lloonngg ddeeffaauulltt__sskkiinn;;
           is the skin number of the model.  This is used for things
           with different skins (like players or armors).

        vveecc33__tt ddeeffaauulltt__oorriiggiinn;;
           is the origin of the entity.

        vveecc33__tt ddeeffaauulltt__aanngglleess;;
           is the orientation of the entity.

     ppaarrssee rroouuttiinnee

          if (StaticEntityCount > 127) error("Too many static entities");
          StaticEntityCount++;
          default_modelindex = ReadByte;
          default_frame = ReadByte;
          default_colormap = ReadByte;
          default_skin = ReadByte;
          for (i=0 ; i<3 ; i++) {
            default_origin[i] = ReadCoord;
            default_angles[i] = ReadAngle;
          }

  66..2222..  ssppaawwnnbbiinnaarryy

     IIDD 00xx1155

     ppuurrppoossee
        This is OBSOLETE. It should never occur in DEM files.

     ppaarrssee rroouuttiinnee

          error ("CL_ParseServerMessage: Illegible server message\n");

  66..2233..  ssppaawwnnbbaasseelliinnee

     IIDD 00xx1166

     ppuurrppoossee
        This message creates a dynamic entity and sets the internal
        default values.

     vvaarriiaabblleess

        lloonngg eennttiittyy;;
           is the number of the entity.

        lloonngg ddeeffaauulltt__mmooddeelliinnddeexx;;
           is the model number in the model-table.

        lloonngg ddeeffaauulltt__ffrraammee;;
           is the frame number of the model.

        lloonngg ddeeffaauulltt__ccoolloorrmmaapp;;
           is the colormap number to display the model.

        lloonngg ddeeffaauulltt__sskkiinn;;
           is the skin number of the model. This is used for things with
           different skins (like players or armors).

        vveecc33__tt ddeeffaauulltt__oorriiggiinn;;
           is the origin of the entity.

        vveecc33__tt ddeeffaauulltt__aanngglleess;;
           is the orientation of the entity.

     ppaarrssee rroouuttiinnee

          entity = ReadShort;
          if (entity > 449) error("CL_EntityNum: %i is an invalid number", entity);
          default_modelindex = ReadByte;
          default_frame = ReadByte;
          default_colormap = ReadByte;
          default_skin = ReadByte;
          for (i=0 ; i<3 ; i++) {
            default_origin[i] = ReadCoord;
            default_angles[i] = ReadAngle;
          }

  66..2244..  tteemmpp__eennttiittyy

     IIDD 00xx1177

     ppuurrppoossee
        This message creates a temporary entity.

     vvaarriiaabblleess

        lloonngg eennttiittyyttyyppee;;
           is the type of the temporary entity.  There are two kinds of
           temporary entities:

           ppooiinntt eennttiittyy
              is a small point like entity.

              value    QuakeC             purpose
                  0    TE_SPIKE           unknown
                  1    TE_SUPERSPIKE      superspike hits (spike traps)
                  2    TE_GUNSHOT         hit on the wall (Axe, Shotgun)
                  3    TE_EXPLOSION       grenade/missile explosion
                  4    TE_TAREXPLOSION    explosion of a tarbaby
                  7    TE_WIZSPIKE        wizard's hit
                  8    TE_KNIGHTSPIKE     hell knight's shot hit
                 10    TE_LAVASPLASH      Chthon awakes and falls dead
                 11    TE_TELEPORT        teleport end

           llaarrggee eennttiittyy
              is a 2 dimensional entity.

               value    QuakeC           purpose
                   5    TE_LIGHTNING1    flash of the Shambler
                   6    TE_LIGHTNING2    flash of the Thunderbolt
                   9    TE_LIGHTNING3    flash in e1m7 to kill Chthon

        lloonngg eennttiittyy;;
           is the entity which created the temporary entity.

        vveecc33__tt oorriiggiinn;;
           is the origin of the entity.

        vveecc33__tt ttrraaccee__eennddppooss;;
           is the destination of the large temporary entity.

     ppaarrssee rroouuttiinnee

          entitytype = ReadByte;
          if (entitytype > 11)
            error("CL_ParserTEnt: bad type");
          switch (entitytype) {
            case 0,1,2,3,4,7,8,10,11:
                   for (i=0 ; i<3 ; i++) org[i] = ReadCoord;
            break;
            case 5,6,9:
                   entity = ReadEntity;
                   for (i=0 ; i<3 ; i++) origin[i] = ReadCoord;
                   for (i=0 ; i<3 ; i++) trace_endpos[i] = ReadCoord;
            break;
          }

  66..2255..  sseettppaauussee

     IIDD 00xx1188

     ppuurrppoossee
        Set the pause state. The time stands still but all entities get
        their update messages.

     vvaarriiaabblleess

        lloonngg ppaauusseessttaattee;;
           is 1 to start the pause and 0 to stop it.

     ppaarrssee rroouuttiinnee

          pausestate = ReadByte;
          if (pausestate) {
            // pause is on
          }
          else {
            // pause is off
          }

  66..2266..  ssiiggnnoonnuumm

     IIDD 00xx1199

     ppuurrppoossee
        This message selects the client state.

     vvaarriiaabblleess

        lloonngg ssiiggnnoonn;;
           is the client state.  The possible values are:

       value    purpose
       1        after model/sound precache, start spawning entities (``prespawn'')
       2        start initializing light effects
       3        start 3D rendering

     ppaarrssee rroouuttiinnee

          signon = ReadByte;

  66..2277..  cceenntteerrpprriinntt

     IIDD 00xx11AA

     ppuurrppoossee
        Prints the specified text at the center of the screen.

     vvaarriiaabblleess

        cchhaarr** tteexxtt;;
           is the text to be displayed.

     ppaarrssee rroouuttiinnee

          text = ReadString;

  66..2288..  kkiilllleeddmmoosstteerr

     IIDD 00xx11BB

     ppuurrppoossee
        This message indicates the death of a monster.

     vvaarriiaabblleess

        lloonngg kkiilllleedd__mmoonnsstteerrss;;
           is the number of killed monsters.  It may be displayed with
           the console command sshhoowwssccoorreess.

     ppaarrssee rroouuttiinnee

          killed_mosters++;

  66..2299..  ffoouunnddsseeccrreett

     IIDD 00xx11CC

     ppuurrppoossee
        This message receives a client, if the player enters a secret
        area.  It comes usually with a pprriinntt message.

     vvaarriiaabblleess

        lloonngg ffoouunndd__sseeccrreettss;;
           is the number of found secrets. It may be displayed with the
           console command sshhoowwssccoorreess.

     ppaarrssee rroouuttiinnee

          found_secrets++;

  66..3300..  ssppaawwnnssttaattiiccssoouunndd

     IIDD 00xx11DD

     ppuurrppoossee
        This message starts a static (ambient) sound not connected to an
        entity but to a position.

     vvaarriiaabblleess

        vveecc33__tt oorriiggiinn;;
           is the origin of the sound.

        lloonngg ssoouunnddnnuumm;;
           is the sound number in the sound-table.

        ffllooaatt vvooll;;
           is the volume (0.0 off, 1.0 max)

        ffllooaatt aatttteennuuaattiioonn;;
           is the attenuation of the sound.  Possible values (for all
           kind of sounds) are:

       value    QuakeC         purpose
       0        ATTN_NONE      i. e. player's death sound doesn't get an attenuation
       1        ATTN_NORM      the normal attenuation
       2        ATTN_IDLE      idle monsters get this attenuation
       3        ATTN_STATIC    all spawnstaticsound messages get thisattenuation

     ppaarrssee rroouuttiinnee

          for (i=0 ; i<3 ; i++) origin[i] = ReadCoord;
          soundnum = ReadByte;
          vol = (float) ReadByte / 255.0;
          attenuation = (float) ReadByte / 64.0;

  66..3311..  iinntteerrmmiissssiioonn

     IIDD 00xx11EE

     ppuurrppoossee
        Displays the level end screen. Depending on the mmuullttii command in
        the serverinfo message this is either the single player summary
        screen or the multi player ranking screen.

     ppaarrssee rroouuttiinnee
        none

  66..3322..  ffiinnaallee

     IIDD 00xx11FF

     ppuurrppoossee
        Displays the episode end screen and some text.

     vvaarriiaabblleess

        cchhaarr** tteexxtt;;
           is the episode end text.

     ppaarrssee rroouuttiinnee

          text = ReadString;

  66..3333..  ccddttrraacckk

     IIDD 00xx2200

     ppuurrppoossee
        This message selects the audio CD track numbers.

     vvaarriiaabblleess

        lloonngg ffrroommttrraacckk;;
           is the start track.

        lloonngg ttoottrraacckk;;
           is the last track. Both values are equal at the start of a
           game but become 2 and 3 at the end of an episode.

     ppaarrssee rroouuttiinnee

          fromtrack = ReadByte;
          totrack = ReadByte;

  66..3344..  sseellllssccrreeeenn

     IIDD 00xx2211

     ppuurrppoossee
        Displays the help and sell screen.

     ppaarrssee rroouuttiinnee
        none

  66..3355..  uuppddaatteeeennttiittyy

     IIDD >>==00xx8800

     ppuurrppoossee
        This is the general entity update message. For every entity
        (potentially) in sight the server sends such a message. The
        message contains only the values, which changed since the
        creation (or spawning) of the entity (with spawnstatic,
        spawnbaseline).

     vvaarriiaabblleess

        lloonngg mmaasskk;;
           is a bit mask to reduce the amount of data to be sent. Only
           the changed parts get their bit and their values.

        lloonngg eennttiittyy;;
           is the entity number.

        lloonngg mmooddeelliinnddeexx;;
           is the model number in the model-table.

        lloonngg ffrraammee;;
           is the frame number of the model.

        lloonngg ccoolloorrmmaapp;;
           is the colormap number to display the model.

        lloonngg sskkiinn;;
           is the skin number of the model. This is used for things with
           different skins (like players or armors).
        lloonngg aattttaacckk__ssttaattee;;
           shows how the entity attacks.  I'm not really sure about the
           explanation because I found only the values 0 and 2 in DEM
           files.  The possible values are:

               value    QuakeC         purpose
               0        none           don't attack
               1        AS_STRAIGHT    straight shot
               2        AS_SLIDING     move to a side
               3        AS_MELEE        single combat (dog, ogre)
               4        AS_MISSILE      shooting attack

        vveecc33__tt oorriiggiinn;;
           is the origin of the entity.

        vveecc33__tt aanngglleess;;
           is the orientation of the entity.

        lloonngg nneeww;;
           is 1 if the entity gets some really new values (modelindex
           etc.)

     ppaarrssee rroouuttiinnee

          mask = ID & 0x07F;
          if (mask & 0x0001) mask |= (ReadByte) << 8;
          entity = mask & 0x4000 ? ReadShort : ReadByte;
          modelindex = mask & 0x0400 ? ReadByte : default_modelindex;
          frame = mask & 0x0040 ? ReadByte : default_frame;
          colormap = mask & 0x0800 ? ReadByte : default_colormap;
          skin = mask & 0x1000 ? ReadByte : default_skin;
          attack_state = mask & 0x2000 ? ReadByte : default_attack_state;
          origin[0] = mask & 0x0002 ? ReadCoord : default_origin[0];
          angles[0] = mask & 0x0100 ? ReadAngle : default_angles[0];
          origin[1] = mask & 0x0004 ? ReadCoord : default_origin[1];
          angles[1] = mask & 0x0010 ? ReadAngle : default_angles[1];
          origin[2] = mask & 0x0008 ? ReadCoord : default_origin[2];
          angles[2] = mask & 0x0200 ? ReadAngle : default_angles[2];
          new = mask & 0x0020 ? 1 : 0;

  77..  VVeerrssiioonn HHiissttoorryy aanndd AAcckknnoowwlleeddggeemmeennttss

     00..00..11,, 77 JJuullyy,, 11999966

     +o  First version (working paper) completed.

     +o  Many thanks to Steffen Winterfeldt (wwffeellddtt@@ttpphh110000..pphhyyssiikk..uunnii--
        lleeiippzziigg..ddee) for his unbelievable reverse engineering work. He
        worked out all the structure information.

     00..00..22,, 88 JJuullyy,, 11999966

     +o  Stupid spawnstatic error corrected.

     00..00..33,, 99 JJuullyy,, 11999966

     +o  I finally understood the multi player recordings.

     +o  More info on sound, particle, spawnstaticsound.

     00..00..44,, 1144 JJuullyy,, 11999966

     +o  Many new values decoded.

     +o  Tables for weapons and status line.

     +o  More general remarks.

     00..00..55,, 1166 JJuullyy,, 11999966

     +o  Many new values decoded.

     +o  Variables entry in the message description.

     +o  Life-cycles.

     11..00..00,, 2288 JJuullyy,, 11999966

     +o  QuakeC is published. Many things get their right names now.

     +o  Life-cycles for multi player.

     +o  This version is the first reliable one.

     11..00..11,, 2299 JJuullyy,, 11999966

     +o  Almost all identifier names match now the QuakeC names.

     +o  Grammer check by SW.

     11..00..22,, 3300 JJuullyy,, 11999966

     +o  Serious semantic mistake corrected (spawn/update).

     +o  Some minor layout improvements.

  88..  AAbboouutt tthhiiss ddooccuummeenntt

  I wrote this document in Linuxdoc-SGML 1.5 with a small patch for the
  HTML table support.  You can get the SGML source at my games page
   <<hhttttpp::////wwwwww..pphhyyssiikk..uunnii--lleeiippzziigg..ddee//~~ggiirrlliicchh//ggaammeess//>.  From the source
  you can create a plain or formatted ASCII text, PostScript and HTML
  versions of this document.

